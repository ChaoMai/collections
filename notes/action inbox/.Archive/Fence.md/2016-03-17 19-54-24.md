# Fence and  memory_order_relaxed

除了在原子操作中标记memory ordering外，还可以单独使用fence指定memory ordering。Fence是全局的操作，它影响所执行线程中其他原子操作的ordering。

```cpp
void write_x_then_y() {
  x.store(true,memory_order_relaxed);
  atomic_thread_fence(memory_order_release);
  y.store(true,memory_order_relaxed);
}

void read_y_then_x() {
  while(!y.load(memory_order_relaxed));
  atomic_thread_fence(memory_order_acquire);
  if(x.load(memory_order_relaxed))
    ++z;
}
```

上面的代码中，如果没有显式的fence，`z`的值是确定的。

关于fence，有几个synchronizes-with规则：

* 如果acquire操作能读取到位于release fence后面store的写入的值，那么这个fence synchronizes-with acquire操作。
* 如果位于acquire fence前面的load操作能够读取到release操作的值，那么这个release操作synchronizes-with acquire fence。
* 如果位于acquire fence前面的load操作能够读取到位于release fence后面的store写入的值，那么release fence synchronizes-with acquire fence。

对于上面的代码，因为y的load能够读取到前面写入的值（由于fence存在，保证了ordering），所以release fence synchronizes-with acquire fence。