# C++模板与泛型编程

模板到特定函数或者类的转化发生在**编译时**。

# 定义模板

## 函数模板

在模板定义中，模板参数列表包含第一个或多个模板参数，且列表不能为空。模板参数列表表示在类或函数定义中用到的**类型或值**。

使用模板时，**隐式或显式地**定义**模板实参**，将其绑定到模板参数上。

当使用一个函数模板时，编译器通常用函数实参了来推断模板实参，编译器用推断出的模板参数来为**实例化**一个特定版本的函数。实例化时，编译器使用**实际的模板实参**代替对应的模板参数来创建一个新*实例*。

```cpp
template <typename T>
int compare(const T &v1, const T &v2) {
  if (v1 < v2) {
    return -1;
  }

  if (v1 > v2) {
    return 1;
  }

  return 0;
}

// 实例化为int compare(const int&, const int&)
compare(1, 0);
```

### 模板类型参数

模板类型参数前必须使用class或typename。在模板参数列表中，这两个关键字的**含义相同**，可以**互换使用**和在同一个模板参数列表中**同时使用**。

```cpp
template <typename T>
int compare(const T &v1, const T &v2) // ...
```

compare有一个模板类型参数T，一般来说，可以将类型参数看作类型说明符，类似内置类型或类类型说明符。

类型参数可用于，

* 指定返回类型或函数的参数类型
* 函数体内的变量声明或类型转换

### 非模板类型参数

非模板类型参数表示一个**值**，使用一个**特定的类型名**来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供或编译器推断出的值所代替，这个值必须是**常量表达式**，因为编译器在编译时需要实例化模板，此时必须知道值是多少。

```cpp
template <typename T, size_t N>
T *arr_begin(T(&arr)[N]) {
  return static_cast<T *>(arr);
}
```

一个非类型参数可以是，

* 一个整型
* 一个指向对象或函数类型的指针
* 左值引用

关于绑定到非类型参数的实参，要注意，

* **必须是一个常量表达式**
* 绑定到指针或非类型参数的实参必须有**静态的生存期**，**不能**用一个普通的局部变量或动态对象作为指针或引用非类型模板参数的实参
* 指针参数可用nullptr或值为0的常量表达式来实例化

由于模板非类型参数是一个常量值，在**需要常量表达式的地方**，可以使用非类型参数。

```cpp
template <typename T, size_t N>
constexpr size_t constexpr_arr_size(T(&arr)[N]) {
  return N;
}

constexpr int size = constexpr_arr_size(arr);
```

### 模板编译

编译器遇到模板定义时，**并不生成代码**。只有当实例化出一个特定版本时，编译器才会生成代码。

不同于调用函数（只需要函数声明）和使用类对象（只需要类定义，但成员函数的定义不必出现），为了生成一个实例，编译器**必须知道**函数模板或类模板成员函数的定义，也就是说，模板的头文件通常**既包括声明也包括定义**。

模板包含两种名字，

* 不依赖于模板参数的名字
    * 在使用模板时，不依赖于模板参数的名字**必须是**可见的。同时必须保证，实例化时，模板的定义，包括类模板的成员的定义，都必须是可见的
* 依赖于模板参数的名字

## 类模板

编译器**不能**为类模板**推断模板参数类型**。

### 定义

类似函数模板。

### 实例化类模板