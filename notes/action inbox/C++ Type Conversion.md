# C++类型转换

C++中，如果两种类型可相互转换，那么它们就是关联的。关联类型之间的相互转换分为两种，隐式类型转化和显式类型转换。

# 隐式类型转换

隐式转换是自动执行的，不需要程序员介入的。

## 算术转换

算术转换发生在算术类型之间，原则是，尽可能避免损失精度。

1. 对于不同的整型之间，会发生整型提升，小整数类型转换成较大的整数类型

    小于int的整型（char，signed char，unsigned char，short，unsigned short，wchar_t，char16_t，char32_t）会提升为int，unsigned int，long，unsigned long，long long，unsigned long long中最小的一种（能够容纳**原类型所有可能的值**）。

2. 含有无带符号类型的算术转换

    某些情况下是**依赖于机器**的。如果两个运算对象分别是有符号和无符号的，
    * 无符号类型 >= 带符号类型，带符号类型->无符号类型；
    * 无符号类型 < 带符号类型，依赖于机器；
        * 带符号类型**能够存储**所有无符号类型的所有值，无符号类型->带符号类型；
        * 带符号类型**不能够存储**所有无符号类型的所有值，带符号类型->无符号类型。

3. 数组转换成指针

    数组自动转换为指向数组首元素的指针。但下述情况不会发生转换，
    * 作为decltype关键字的参数；
    * 作为&，sizeof，typeid的运算对象；
    * 用一个引用来初始化数组。
    * p221

4. 指针的转换

    * 常量整数值0或字面值nullptr->任意指针类型；
    * 指向任意非常量的指针->void*；
    * 指向任意对象的指针->const void*；
    * p530

5. 算术类型或指针转换成bool类型

    如果算术类型或指针的值为0，转换为false，否则是true。

6. 指针转换成常量

    非常量类型的指针->指向相应的常量类型的指针。

    ```cpp
    int i;
    const int &j = i;
    const int *p = &i;

    // 错误，不允许删除底层const。
    int &r = j, *q = p;
    ```

7. 类类型定义的转换

    转换由类类型定义，编译器自动执行，`while (cin >> s)`。

## 何时发生的隐式转换

* 大多数表达式中，**比int类型小的整型值**首先提升为**较大的整数类型**；
* 在条件中，非bool值转换成bool值；
* 初始化过程中，初始值转换成变量的类型；
* 在赋值语句中，右侧运算对象转换成左侧运算对象的类型；
* 算术运算和关系运算中，运算对象如果有多种类型，则需要转换成同一种类型。

# 显示类型转换