# 文档和资源

* [语言规范](https://golang.org/ref/spec)
* [go命令行文档](https://golang.org/doc/cmd)
* [包列表](https://golang.org/pkg/)
* [go wiki](https://github.com/golang/go/wiki)
* [The Go Blog](https://blog.golang.org/index)

# Packages

每个go程序都由package构成。

## Exported name

在一个包中，如果一个name是以大写字母开头的，那么这个name将会被从这个包中导出。

当import一个包的时候，只能引用**被导出**的name。

## 函数

### 参数

参数名称在前，类型在后，[Go's Declaration Syntax](https://blog.golang.org/gos-declaration-syntax)。

当多个连续的函数参数有共同的类型是，可以省略不写除最后一个外的类型。

```go
func add(s string, x, y int) int {
	return x + y
}
```

### 返回值

一个函数可以返回任意个数的结果。

返回值可以是有名字的。当`return`不带任何参数时，函数返回named return values，这叫做"naked" return。

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

### 变量

`var`声明多个变量时，只能写最后一个的类型。

```go
var c, python bool

// error
// var c int, python bool
```

如果声明时给出了初始值，那么会以初始值的类型作为变量的类型，此时声明中的类型可省略。

在函数内部可以用短变量声明`:=`来声明变量，类型由值的类型来决定。但在函数外部，由于所有语句都需要以关键字开头，因此不可用这个方法。

### 基本数据类型

```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128
```

声明变量但不显式给出初始值，变量会被赋予零值。数值类型：`0`，bool类型：`false`，string：`""`。

### 类型转换和推断

在进行类型转换时，go只能使用**显式**类型转换。

使用`:=`或`var =`声明变量、未指明类型、但给出初始值时，变量的类型由对初始值进行类型推断得到。如果右侧是数值常量，那么变量的类型可能是`int`，`float64`，`complex128`。

### 常量

只可以用`const`来声明。数值常量可表示任意精度，且不会溢出。一个未指定类型的常量由上下文来决定其类型。

# 语句

## for

```go
// 对比c语言，括号可选、大括号必须
for i := 0; i < 10; i++ { ... }
    
// 初始化语句和循环的每次更新可省略
for ; sum < 1000; { ... }
    
// 可当做while使用
for sum < 1000 { ... }
    
// 无限循环
for { ... }
```
    
## if

```go
// 对比c语言，括号可选、大括号必须
if x < 0 { ... }
    
// 可以使用短语句，在判断之前执行，语句中声明的变量仅在if和后续的else语句块中可用
if v := math.Pow(x, n); v < lim { ... }
    
// else不能换行写
if v := math.Pow(x, n); v < lim {
    ...
} else {
    ...
}
```
    
## switch

求值顺序，按case的顺序，自上向下进行。

```go
// 对比c语言，
// break可选，不写时自动提供
// case不必是integer
    
switch os := runtime.GOOS; os {
 case "darwin":
     fmt.Println("OS X.")
 case ...
     ...
	
 // 不带条件的switch相当于switch true
 switch {
 case t.Hour() < 12:
     fmt.Println("Good morning!")
case ...
    ...
```
    
## defer

使用`defer`时，被`defer`的函数会被push到一个stack，参数会**立即计算**，但语句块结束时，stack中的函数才会被pop出来执行。

```go
func t(s string) string {
    fmt.Printf("in func t: %s\n", s)
    return s
}

func main() {
    {
        defer fmt.Println(t("you"))
        fmt.Println("fuck")
    }
}
    
// output:
// in func t: you
// fuck
// you
```
    
`defer`的函数可以读取和赋值到函数的返回值。
    
```go
func c() (i int) {
    defer func() { i++ }()
    return 1
}
    
// c返回2
```
    
**defer、panic和recover**

[Defer, Panic, and Recover](https://blog.golang.org/defer-panic-and-recover)
    
当调用`panic`时，所有`defer`的函数都被正常执行。然后函数返回到调用者。
    
`recover`仅在`defer`的函数中有用，正常执行时调用，只会返回`nil`。
    
```go
func main() {
    f()
    fmt.Println("Returned normally from f.")
}
    
func f() {
    // g发生panic后，这个deferred的函数会执行，并捕获panic
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    fmt.Println("Calling g.")
    g(0)
    fmt.Println("Returned normally from g.")
}
    
func g(i int) {
    if i > 3 {
        fmt.Println("Panicking!")
        panic(fmt.Sprintf("%v", i))
    }
    defer fmt.Println("Defer in g", i)
    fmt.Println("Printing in g", i)
    g(i + 1)
}
```

# 其他类型

## 指针

存储了内存地址，零值为`nil`。`&`获得变量的地址，`*`解引用。

对比c的指针，go的指针无法进行算数运算。

```go
var p *int

i := 42
p = &i
```

## Struct

字段的集合，使用`.`来访问字段。对于struct指针，可以使用`(*p).X`或直接使用`p.X`来进行访问。

对比c，go不能用`->`来访问成员。

在分配结构体时，结构体字面值指定了字段的值。

```go
var (
    v1 = Vertex{1, 2}  // has type Vertex
    v2 = Vertex{X: 1}  // Y:0 is implicit
    v3 = Vertex{}      // X:0 and Y:0
    p  = &Vertex{1, 2} // has type *Vertex
)
```

## Array

和c一样，数组的大小也是数组类型的一部分，声明数组时必须有大小。

```go
var a[10] int

// 数组字面值
primes := [6]int{2, 3, 5, 7, 11, 13}
```

## Slice

slice的类型为`[]int`，对数组进行`a[low:high]`后得到，区间是前开后闭，可以省略`low`或`high`，默认值分别为`0`和数组长度。

```go
var a[10]
a[:4]
a[:]
```

**slice和array**

slice本身并不存储任何数据，仅仅是数组选定区间的描述，和数组共享底层的数据。`len()`和`cap()`对应了slice的长度，和底层数组从`low`起的大小，即：`len(array) - low`。

对已有slice再做一次slice，实际上是改变slice对底层数组的引用范围。

```go
s := []int{2, 3, 5, 7, 11, 13}

// Slice the slice to give it zero length.
s = s[:0]

// Extend its length.
s = s[:4]
```

slice字面值类似数组的，区别是没有大小。底层实际上创建了相同大小的数组，然后再创建slice。

**Nil Slice**
`var s []int`声明了一个Nil slice，`len`和`cap`都为0，且不会分配底层的数组。

**make slice**

通过`make`来创建动态长度的数组。

```go
a := make([]int, 5)  // len(a)=5, cap(a)=5
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
```

**append**

`append`函数能够将相同类型元素追加至现有slice，若底层数组大小不够，则会重新分配内存，并将slice指向新数组。

```go
func append(s []T, vs ...T) []T
```

**range**

除了普通方法遍历slice，还能使用`range`，

```go
// i是index，v是相应元素的copy。
for i, v := range s { ... }

// 可忽略i或v的赋值
for _, value := range s { ... }

for i, _ := range s { ... }
// 或
for i := range s { ... }
```

## Map

一个仅做了声明的map是`nil`，需要使用`make`来进行初始化。

```go
type Vertex struct {
    Lat, Long float64
}

var m map[string]Vertex

fmt.Println(m == nil) // true
m = make(map[string]Vertex)
m["Bell Labs"] = Vertex{
    40.68433, -74.39967,
}
```

map字面值和struct字面值类似。

```go
var m = map[string]Vertex{
    "Bell Labs": Vertex{ 40.68433, -74.39967,}
}

// 当最上层的类型只是类型名的时候，可以省略。
var m = map[string]Vertex{
    "Bell Labs": { 40.68433, -74.39967,}
}
```

**操作**

* 新增和更新：`m[key] = elem`
* 访问key的值：`elem = m[key]`
* 删除：`delete(m, key)`
* test：`elem, ok = m[key]`，如果不存在，那么`elem`为此类型的零值。

## Function values

函数也是值，可作为参数传递，作为返回值返回。

闭包是function value引用了函数体外部的变量，函数可以访问和修改这些变量。换句话说，闭包包含了**函数、以及所在的环境的上下文**。

# 方法和接口

## 方法

方法是带有特殊receiver参数（`func`和函数名之间）的函数。这个receiver不必是struct，但要求receiver的类型定义必须在同一个package里面，且不能直接将内置类型作为receiver。

```go
type Vertex struct { X, Y float64 }
func (v Vertex) Abs() float64 { ... }

type MyFloat float64
func (f MyFloat) Abs() float64 { ... }
```

**Point receiver**

若要修改字段，则必须使用point receiver，**无论变量本身是否是指针类型**，**非指针receiver调用时发生了copy**。

从这里可以得出使用point receiver的场景：1. 避免copy；2. 修改值本身。一般来说，某个类型的receiver应该**统一**，要么是point receive，要么是普通receiver。

```go
func (v *Vertex) Scale(f float64) { v.X = v.X * f ... }
func (v Vertex) Scale2(f float64) { v.X = v.X * f ... }
```

* 若v不是指针类型，那么go会把`v.Scale`自动转换为`（&v）.Scale`。
* 反过来，若v是指针类型，在调用`Scale2`时，go会把`v.Scale2`转换为`（*v).Scale2`。

对比c++的成员函数，`this`指针类似于point receiver，但go的普通receiver是不同于c++的。

## 接口

接口是方法签名的集合。

接口的实现是隐式的，无需类似`implement`的关键字。隐式实现**解耦**接口的定义和实现，在package中，接口的定义可以出现在方法和类型定义之后。注意方法的实现**区分普通receiver和point receiver**。

一个接口类型的值可以是**任何实现了接口中所有方法的值**。接口值可以看做是值和具体类型的元组，调用接口值的方法，实际上会调用具体类型的方法。

```go
type Abser interface { Abs() float64 }

type MyFloat float64
func (f MyFloat) Abs() float64 { ... }

type MyInt int64
func (f MyInt) Abs() int64 { ... }

type Vertex struct { X, Y float64 }
func (v *Vertex) Abs() float64 { ... }

var a Abser
f := MyFloat(1)
i := MyInt(2)
v := Vertex{3, 4}

a = f
a = i
a = &v

// a = v
// error
```

对比c++的多态，c++中通过继承基类，并覆盖基类的虚函数，在运行时进行动态绑定，以此实现多态。go的接口方法定义可以看做是基类和虚函数，而`a = f`相当于将子类的指针赋值给基类指针，这样完成了动态绑定。

不同的点还是receiver，实现接口的方法时，go区分了point receiver和普通receiver。

**空的具体类型值**

如果接口的具体类型是空的，那么将会使用`nil` receiver来调用方法，不引发空指针异常。

```go
type Abser interface { Abs() float64 }

type Vertex struct { X, Y float64 }
func (v *Vertex) Abs() float64 { if v == nil { ... }  ... }

var i Abser
var v *Vertex
i = v

i.Abs()
// or
v.Abs()
```

**空的接口值**

会发生运行时错误，没有具体的`Abs`方法可以调用。

```go
type Abser interface { Abs() float64 }
var i Abser
i.Abs()
```

**空接口**

空接口的值可以包含任何类型。

```
var i interface {}
i = 32
i = "fuck"

// i = 100000000000000000000000000
// overflows int
```

对于数值类型，底层的具体类型**只能是**`int`，`float64`，`complex128`。

**类型断言**

类型断言提供了访问接口底层具体类型值的能力。

* `t := i.(T)`断言接口`i`拥有具体类型`T`，并把类型`T`的值赋值给`t`。如果不是类型`T`，则触发panic。
* test：`t, ok := i.(T)`断言不正确的情况，不触发panic，而是`ok`为false，且t为类型`T`的零值。

```go
var i interface{} = 100000000000000000000000000 // overflow
a := i.(int64)

var i interface{} = 100000
a := i.(int64) // int
```

Type swtiches是允许断言多个类型的结构。类似switch语句，但是每个case是特定的类型。

```go
// 如果test成功，那么v会转换为相应的类型。

switch v := i.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}
```

对比scala的pattern matching，go的type swtiches像，但不是pattern matching。scala的pattern matching会检查值和pattern是否匹配，能够把值解构为构成值的各部分。**猜测**go的type swtiches是类型字符串是否相等的test。

## 一些内置的接口

**Stringer**

类似python的`__str__`，定义在`fmt`中。

```go
type Stringer interface {
    String() string
}

type A ...
func (a A) String() string { return "fuck" }

a := A()
fmt.Println(a) // fuck
```

**error**

类似Stringer，fmt在print的时候也会查找`error`接口。从fmt的实现上看，是error**优先**。

```go
type error interface {
    Error() string
}
```

error更适合用于专门定义的错误类型。否则功能上，stringer和error就冗余了。

**Reader**

io包定义了`io.Reader`接口，代表读取stream，有多个实现（文件、网络等）。

其中`func (T) Read(b []byte) (n int, err error)`方法使用现有数据填充`b`，并返回填充的字节数和`error`。stream结束时，`error`为`io.EOF`。

# 并发

## Goroutines

由go运行时管理的轻量级线程。

```go
go f(x, y, z)
```

参数的计算在当前goroutine中完成，函数`f`的调用发生在新的goroutine。

## Channels

channel是带类型的管道（typed conduit）。默认情况下，发送方和接收方会一直阻塞到另一方ready。

```go
ch := make(chan int)

ch <- v
v := <-ch
```

**buffered channel**

`ch := make(chan int, 100)`，buffered channel在满或空的情况下，分别会导致发送方和接收方阻塞。

**range**

`for i := range ch`可以从channel逐个接收值，直到channel被关闭。

**close**

* 发送方可以通过`close(ch)`来告诉接收方没有后续的值会发送。
* 接收方可以使用`v, ok := <-ch`判断channel是否被关闭。

**select**

select语句可以让goroutine等待多个通信操作，block直到其中某个case能执行。如果同时有多个case能执行，则随机选择一个。

若存在default，则当没有case ready的时候，执行default。

```go
select {
case i := <-c:
    // use i
default:
    // receiving from c would block
}
```

**mutex**

互斥量，定义在sync包中。

```go
Lock
Unlock
```

## 并发模式

* [Go Concurrency Patterns](https://www.youtube.com/watch?v=f6kdp27TYZs)
* [Advanced Go Concurrency Patterns](https://www.youtube.com/watch?v=QDDwwePbDtw)

## 内存模型

[The Go Memory Model](https://golang.org/ref/mem)

# 最佳实践

[Effective Go](https://golang.org/doc/effective_go.html)

# 总结

抛开go的运行时环境和gc不说，go很像c，同时还有着少量函数式语言的特性。

go中，我很喜欢的几点是：

1. 变量和函数的声明简洁清晰    
2. goroutine
3. 提供了CSP来实现goroutine之间的通信

