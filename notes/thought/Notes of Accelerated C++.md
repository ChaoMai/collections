[c/c++, programming language 编程语言]

# Notes of Accelerated C++

# 第1章 字符串的使用

变量是一个具有名称的对象，对象是计算机中一段具有类型的内存空间。

刷新缓冲区：

* 缓冲区已满
* 请求库从标准输入流中读数据
* 明确要求刷新

`const`：变量的生命周期内不可更改，被用于初始化的数值无需是一个常量。

`char`：内建类型
`wchar_t`：内建类型，用于保存“宽字符”

# 第2章 循环与计数

## 循环条件的编写

这里出现的问题是，如何确定循环的次数，是i、i+1，还是i-1。一个有效的方法是，使用*循环不变式*，

```cpp
// 不变式：目前为止，我们已经输出了r行

int r = 0;
// 将r设为0，让不变式为真
while (r ！= rows) {
    // 在这里，可以假定不变式为真
    // 输出一行，令不变式为假
    std::cout << std::endl;

    // 对r加1，使不变式再次为真
    ++r;
}
// 可以断定，在这里不变式为真
```

并且保证，不变式在循环开始之前以及到达循环体结尾的时刻都为真。只要能保证这个条件，那么在循环结束的时候，不变式也为真。

`std::string::size_type`：存储字符串长度的时候应该使用。

## 为什么是不对称区间？

半开区间：[开始值， 越界值)，
```cpp
for (int i = 0; i != rows, ++i) {
}
```

1. 直观

$[m, n)$：包含$n - m$个元素
$[m, n]$：包含$n - m + 1$个元素

空区间的表示：
$[n, n)$，但是如果是对称区间$[n, n - 1]$

2. 便于不变式的表达

从0开始表明：到目前为止，已经处理了i次。

3. 条件检测方便

$[m, n)$：`r != rows`。循环结束时，`r == rows`，不变式表明已经处理了rows次。
$[m, n]$：`r <= rows`。循环结束时，说明至少处理了rows次，意思上不便于不变式的表达。

同时在设置精确执行次数的时候，半开区间更方便，`r != 执行次数`，即可。

# 第3章 使用批量数据

如果不明确初始化内部类型的局部变量，那这些变量会被默认初始化，内部类型的默认初始化意味着值未定义的。未定义的数值只能用作赋值运算的左操作数。

无符号整数和普通整数在同一表达式中时，普通整数会被转换为无符号整数，因此`homework.size() - 100`会产生无符号结果，即使`homework.size() < 100`。

# 第4章 组织程序和数据

引用：一个特定对象的另一个名称。

* 定义一个引用的引用与定义原来对象的引用效果是一致的。
* 一个非常量引用不能指向一个常量对象或常量引用。

函数：一个函数在每一个使用它的源文件中被声明，函数仅被定义一次。

重载：使几个函数具有同样的函数名。

`inline`: 在适当的条件下请求编译器将调用扩展成内联子过程。带有`inline`的函数通常在头文件中定义。

左值：指示非临时对象的值。一个产生算术值得表达式，并不是左值。

非常量引用参数：非常量引用参数对应的参数必须是左值。因为可能会更改原来的对象。

异常的副作用：

`try`和`catch`之间的任何东西都有可能发生异常，但是源代码中紧跟异常发生点之后的运算，与实际执行的顺序，并不一定是对应的。

```cpp
// 这个示例不能正常工作
try {
streamsize prec = cout.precision();
count << "Your final grade is " << setprecision(3)
      << grade(midterm, final, homework) << setprecision(prec);
}
```

上面运算符是从左到右的执行，但操作数的计算并不一定是。这就会导致在触发异常前就输出了一些额外的东西，这个`cout`语句包含了多个副作用（抛出异常是一个，还有可能的额外输出）。

头文件：头文件应该只声明必要的名称，使用完整的限定名。为用户保留最大限度的灵活性。

`#include`：

* `#include<系统头>`：系统头可能是以文件实现的，但也可能不是。
* `include "用户定义的头文件"`：编译器将此头文件中的所有内容复制到被include的地方。为了保证不被声明多次，需要使用预处理变量，*注释也要包含在里面*。

# 第5章 使用顺序容器和分析字符串

vector `erase`：由于vector是为了快速随机存取而被优化的，但是代价是，在除了vector结尾的其他地方插入或者删除元素的开销可能会非常大，需要移动位于被插入或者删除元素后面的全部元素。
同时，由于元素发生了移动，因此指向被移动元素的iterator会失效。插入元素可能会导致整个vector重新分配，所有的iterator也都会失效。

vector `reserve`：保留空间以保存n个元素，也就是增加了capacity。新的capacity必须大于现有的capacity，否则这个函数什么都不做。成功执行以后，先前所有的iterator都失效。

iterator的类型：

* `container-type::const_iterator`
* `container-type::iterator`

`const_iterator`可以转为`iterator`，反过来不行。

注意：`const_iterator`和`const iterator`不一样，前者是可以iterate all const elements，后者根本无法进行iterate，因为无法对它进行`++`和`--`。

定义一个container：

* `container<T> c`
* `container<T> c(c2)`：c是c2的一个copy。
* `container<T> c(n)`：n个元素的c。每个元素根据T的类型来初始化（数值初始化或类自己的初始化方法）。
* `container<T> c(n, t)`：n个元素的c，每个元素是t的copy。
* `container<T> c(b, e)`：`b`和`e`是iterator，c保存了`[b, e)`元素的copy。

# 第6章 使用库算法
